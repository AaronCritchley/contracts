
.. _api:

PyContracts API
===============

This is a discussion of the |pycontracts| API. 

- See :py:mod:`contracts` for a detailed list of this module's public interface.

- See :ref:`contracts_language_reference` for a description of the domain specific language
  used to describe the contracts.



Using the ``@contract`` decorator.
----------------------------------------------------

The decorator :py:func:`contracts` is the main way to 
define constraints. It is quite flexible, and it is smart enough 
to support functions with variable number of arguments and keyword arguments.

There are three ways to specify the contracts. In order of precedence:

- As arguments to this decorator. 
- As Python 3 function annotations.
- Using ``:type:`` and ``:rtype:`` tags in the function's docstring.

|pycontracts| will try these options in order. Note that, in any case,
only one of these options are chosen. For example, you cannot
use both annotations and docstring for the same function: if annotations
are found, the docstring is not considered.


Using decorator arguments
^^^^^^^^^^^^^^^^^^^^^^^^^

:py:func:`contract` accepts a list of keyword arguments.
Each keyword should correspond to one function argument, plus
the special name ``returns`` is reserved for describing the return value.
An example use would be: ::

    from contracts import contract

    @contract(a='int,>0', b='list[N],N>0', returns='list[N]')
    def my_function(a, b):
        ...
      

The values can be either:

- Strings using |pycontracts|' DSL language (see :ref:`contracts_language_reference`)

- Python types --- in this case |pycontracts| will do a simple :py:func:`isinstance` check.
  This is slightly more clear if the contract is simple: ::

      @contract(a=int, b=float, returns=float)
      def my_function(a, b):
          return a + b


Using Python annotations
^^^^^^^^^^^^^^^^^^^^^^^^

The same rules apply. In this case the syntax would look like this: ::

    from contracts import contract

    @contract
    def my_function(a:'int,>0', b:'list[N],N>0') -> 'list[N]': 
        ...
      


Using functions docstrings
^^^^^^^^^^^^^^^^^^^^^^^^^^

The Python standard library seems to have standardized on the ``:param:``, ``:type:``,
``:return:``, ``:rtype:`` tags to document functions, and tools like Sphinx
can interpret those tags to produce pretty documentation.

|pycontracts| can read contracts declared using the ``:type:`` and ``:rtype:`` tags.
In this way, your function becomes automatically more robust and better documented. 

Here is an example use: ::

    from contracts import contract
    
    @contract
    def my_function(a, b): 
      """ Function description.
  
          :param a: first number
          :type a: int,>0
          :param b: description of b
          :type b: list[N],N>0
      
          :return: a list
          :rtype: list[N]               """
      ...
          
          
.. note:: By convention, those annotations must be parsable as
    reStructuredText. 
    If the contract string has special RST characters in it, like ``*``,
    you can include it in double ticks. |pycontracts| will remove
    the double ticks before interpreting the string.

    For example, the two annotations in this docstring are equivalent
    for |pycontracts|, but the latter is better for Sphinx: ::

      """ My function 
  
          :param a: First parameter
          :type a: list(tuple(str,*))
      
          :param b: First parameter
          :type b: ``list(tuple(str,*))``
      """


Creating new contracts using ``new_contract``
-------------------------------------------------

The function  :py:func:`new_contract`  is used to define new contracts.
It takes two arguments. The first argument is the name
of the new contract, and the second is the value: ::

    new_contract('color', 'list[3](float)')

Once defined, the new contracts can be used as part of more complicated 
expressions: ::

    @contract(colors='list(color)')
    def average_colors(colors):
        pass

The second parameter to ``new_contract`` can be either
a string, a Python type, or a callable function. 

- If it is a string or a type, it is interpreted as contract expression
  like any parameter to :py:func:`@contract`.

- If it is a callable, it must accept one parameter, and either:
  
  * return True or None, to signify it accepts.
  
  * return False or raise ValueError, to signify it doesn't.
  
  If ValueError is raised, its message is used in the error.
  
This function returns a :py:class:`Contract` object. It might be
useful to check right away if the declaration is what you meant,
using :py:func:`Contract.check` and :py:func:`Contract.fail`.  

For example, suppose that you are writing a graphical application
and that many of your functions need arguments representing colors.
It might be a good idea to declare once and for all what is a color,
and then reuse that definition. For example: ::

    color = new_contract('color', 'list[3](number,>=0,<=1)')
    # Make sure we got it right
    color.check([0,0,0])
    color.check([0,0,1])
    color.fail([0,0])
    color.fail([0,0,2])
    
    # Now use ``color`` in other contracts.
    @contract
    def fill_area(inside, border):
        """ Fill the area inside the current figure.
        
            :type border: color
            :type inside: color              """
        ...
        
    @contract
    def fill_gradient(colors):
        """ Use a gradient to fill the area.
        
            :type colors: list[>=2](color)     """
        ...


.. _contractsmeta:

Using the ``ContractsMeta`` meta-class
-------------------------------------------------

The  :py:class:`ContractsMeta` meta-class can be used as a drop-in 
replacement for ``ABCMeta``. It allows you to declare contracts
for a superclass and then have those contracts automatically
enforced for any class that derives from it.

For example, let us define a "timer" interface whose
``start`` method requires a positive number: ::

    from contracts import ContractsMeta, contract
    from abc import abstractmethod

    class TimerInterface():
        __metaclass__ = ContractsMeta

        @abstractmethod
        @contract(interval='(float|int),>0')
        def start(self, interval):
            pass

Now we can subclass  ``TimerInterface`` and all contracts
will be automatically inherited: ::

    class Timer(TimerInterface):
  
        def start(self, interval):
            time.sleep()


    t = Timer()
    t.start(-1) # raises ContractNotRespected

    # contracts.interface.ContractNotRespected: Breach for argument 'interval' to Timer:start().
    # Condition -1 >= 0 not respected
    # checking: >=0               for value: Instance of int: -1
    # checking: (float|int),>=0   for value: Instance of int: -1



