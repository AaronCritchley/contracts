
.. _api:

PyContracts API
=====================

Specifying contracts using decorators and docstrings
------------------------------------------------------------


Using quotes.

:type couples: ``list[>0](tuple(str, *))``
        
|towrite|


Specifying contracts using decorators with explicit contracts.
--------------------------------------------------------------------

|towrite|


Decorate a function explicitly
-------------------------------------------------

|towrite|


Manual API
-------------------------------------------------

.. py:currentmodule:: contracts

In addition to the :py:func:`contracts` decorator, |pycontracts| offers
an interface for checking expressions explicitly. 

The :py:func:`check()` function  allows you to check 
that some value respect a given contract. ::

    from contracts import check
  
    check('tuple(int,int)', (2,2) )

:py:func:`check()` might raise:

:py:class:`ContractSyntaxError`
  If there are parsing errors.

:py:class:`ContractNotRespected`
  If the value does not respect the contract constraints.
  
Both exceptions are instances of :py:class:`ContractException`.
Usually you want to use :py:func:`check()` as a better ``assert()``, so you
don't want to catch those exceptions. The error message should
be descriptive enough.

For example, the message generated by ::

   check('tuple(int, tuple(*,str))', (0, (1, 2)))

is ::

    contracts.ContractNotRespected: Expected a string, got 'int'.
     context: checking: str                       for value: Instance of int: 2
     context: checking: tuple(*,str)              for value: Instance of tuple: (1, 2)
     context: checking: tuple(int,tuple(*,str))   for value: Instance of tuple: (0, (1, 2))

The message shows the recursive matches of expressions, and should be enough
to diagnose the problem. Nevertheless, you can add a third argument to specify a message that will be included
in the error, if one is thrown. For example: ::
 
    score = (2, None)
    check('tuple(int,int)', score, 'Player score must be a tuple of 2 int.' )

Interpreting error messages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the case you are using variables, the matching "context" is shown.
The context is the set of variables which have already bound to values.

For example, suppose you want a tuple with two lists of equal length.
This can be expressed as: ::

    value = ([0,1],[1,2,3]) # invalid
    check('tuple(list[N], list[N])', value)

What happens behind the scenes is that |pycontracts| first matches the
first list, binds the variable ``N`` to the length of that list (=2),
then checks that ``list[N]`` describes the second list. Now, however,
``N`` has already been bound, and the matching fails. The error you would see is: ::

    contracts.ContractNotRespected: Expected that 'N' = 2, got 3.
     context: checking: N (context: N=2)         for value: Instance of int: 3
     context: checking: list[N] (context: N=2)   for value: Instance of list: [1, 2, 3]
     context: checking: tuple(list[N],list[N])   for value: Instance of tuple: ([0, 1], [1, 2, 3])

|pycontracts| tries hard to give you a readable message even with complicated contracts. 
For example, consider the complicated expression: ::

    check('int|str|tuple(str,int)', ('a', 1))
    
Because there is an OR (``|``), |pycontracts| will have to explain to you why 
none of the three OR clauses was satisfied. ::

    contracts.ContractNotRespected: Could not satisfy any of the 3 clauses.
    ---- Clause #0: ----
    | Expected type 'int', got 'tuple'.
    |  context: checking: int               for value: Instance of tuple: ('a', 'b')
    ---- Clause #1: ----
    | Expected a string, got 'tuple'.
    |  context: checking: str               for value: Instance of tuple: ('a', 'b')
    ---- Clause #2: ----
    | Expected type 'int', got 'str'.
    |  context: checking: int               for value: Instance of str: 'b'
    |  context: checking: tuple(str,int)    for value: Instance of tuple: ('a', 'b')
    ------- (end clauses) -------
     context: checking: int|str|tuple(str,int)   for value: Instance of tuple: ('a', 'b')
 

   
Explicit parsing and checking
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The results of parsing are cached internally, there is no performance
penalty in using :py:func:`check()`  often.

If you wish, you can also separate the parsing and checking phases.
The function :py:func:`parse()` will return a :py:class:`Contract` object,
which in turn has a :py:func:`Contract.check()` function you can call. ::

  from contracts import parse
  
  contract = parse('>0')  # May raise ContractSyntaxError
  contract.check(2)       # May raise ContractNotRespected
  

Checking multiple values
^^^^^^^^^^^^^^^^^^^^^^^^
 
The most interesting uses of |pycontracts| are when it is used
to check that multiple objects respect mutual constraints.

You can use :py:func:`check_multiple()` to check that a series of values
respect a series of contracts, that might reference each other's variables.
The argument to  :py:func:`check_multiple()` must be a list of tuples with two elements 
(contract, value).

In the next example, we are defining a table. We want ``data``
to be a list of lists with equal length, and that
``row_labels`` and ``col_labels`` have the expected
length, coherent with ``data``. |pycontracts| allows you
to do all this checks with a remarkably clear, concise, and readable notation. ::

    from contracts import check_multiple

    data = [[1,2,3],
            [4,5,6]]
    row_labels = ['first season', 'second season']
    col_labels = ['Team1', 'Team2', 'Team3']
    
    check_multiple([('list[C](str),C>0', col_labels),
                    ('list[R](str),R>0', row_labels),
                    ('list[R](list[C](numbers))', data) ],
                   'I expect col_labels, row_labels, and data to '
                   'have coherent dimensions.')
                    


Examining the Contract objects
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you want to examine the contract object, use :py:func:`Contract.__repr__()` 
for eval()uable expression,
or :py:func:`Contract.__str__()`  to get back a representation using |pycontracts|' language. ::

    from contracts import parse

    contract = parse(' list[N](int), N > 0')     

    print("%s" % contract)   # => 'list[N](int),N>0'
    print("%r" % contract)   
    # => And([List(BindVariable('N',int),CheckType(int)),
    #         CheckOrder(VariableRef('N'),'>',SimpleRValue(0))])

The latter is useful if you are hacking |pycontracts| and you 
want to check in detail what is going on.


Examining bound variables
^^^^^^^^^^^^^^^^^^^^^^^^^

If you are using binding expression, you can examine 
what variables were bound using the return values.
The functions :py:func:`check()` and :py:func:`Contract.check()` will return
a :py:class:`Context` object.  ::

      context = check('list[N](str), N>0', ['a','b','c'])
      
      print('N' in context)  # => True
      print(context['N'])    # => 3



Extending |PyContracts| with new contracts
-------------------------------------------------

Defines a new contract type. The second parameter can be either
a string or a callable function. 

- If it is a string, it is interpreted as contract expression; 
  the given identifier will become an alias
  for that expression. 
  
- If it is a callable, it must accept one parameter, and either:
  
  * return True or None, to signify it accepts.
  
  * return False or raise ValueError, to signify it doesn't.
  
  If ValueError is raised, its message is used in the error.
  
This function returns a :py:class:`Contract` object. It might be
useful to check right away if the declaration is what you meant,
using :py:func:`Contract.check` and :py:func:`Contract.fail`.  

For example, suppose that you are writing a graphical application
and that many of your functions need arguments representing colors.
It might be a good idea to declare once and for all what is a color,
and then reuse that definition. For example: ::

    color = new_contract('color', 'list[3](number,>=0,<=1)')
    # Make sure we got it right
    color.check([0,0,0])
    color.check([0,0,1])
    color.fail([0,0])
    color.fail([0,0,2])
    
    # Now use ``color`` in other contracts.
    @contracts
    def fill_area(inside, border):
        """ Fill the area inside the current figure.
        
            :type border: color
            :type inside: color
        """
        pass
        
    @contracts
    def fill_gradient(colors):
        """ Use a gradient to fill the area.
        
            :type colors: list(color)
        """
        pass



Developer notes
-------------------------------------------------

|towrite|



Using PyContracts in your own PyParsing-based language
------------------------------------------------------

You can use :py:data:`contract_expression` to add a contract expression
to your PyParsing-based grammar: ::

      from contracts import contract_expression

      from pyparsing import Literal, Optional
      
      my_grammar = ... + Optional(Literal('respects') + contract_expression)



PyContracts public API reference
================================


|towrite|

TODO: add link to pydoctor output


.. py:module:: contracts

Decorating a function
---------------------

.. autofunction:: contracts

.. autofunction:: decorate


Exceptions
----------

.. autoclass:: ContractException

.. autoclass:: ContractSyntaxError

.. autoclass:: ContractNotRespected


Manually checking values
------------------------

.. autofunction:: check

.. autofunction:: check_multiple

.. autofunction:: parse

.. autofunction:: new_contract

.. autoclass:: Contract

   .. automethod:: check

   .. automethod:: fail

   .. automethod:: __repr__()

   .. automethod:: __str__()

.. autoclass:: Context

   .. automethod:: __contains__()
   
   .. automethod:: __getitem__()
    
.. py:data:: contract_expression

   A PyParsing expression that can be used to include
   contracts expression in your own PyParsing grammar.
   
