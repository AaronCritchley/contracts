
..
    A tour of the possibilities
    ===========================

    Here we give a brief tour of the available features (for the complete reference, see :ref:`reference`).
    
The philosophy is to make the simple cases easy, and the difficult
possible, while still retaining readability.

For example, we can either ask for a simple list,
or specify more about it using the additional clauses.

.. list-table::
   :widths: 50 50
   :header-rows: 1

   * - Contract expression
     - Meaning
   * - ``list``
     - An instance of ``list``.
   * - ``list[2]``
     - A list of two elements.
   * - ``list(int)``
     - A list of integers.
   * - ``list(number)``
     - A list of numbers.
   * - ``list[3](number)``
     - A list of exactly three numbers. 
   * - ``list[>=3](number)``
     - A list of at least three numbers.
   * - ``list[>=3](number, >0)``
     - A list of at least three numbers, greater than 0.

|pycontracts| supports the use of variables. 
There are two kinds of variables: lower-case letters (``a``, ``b``, ...)
are general-purpose variables, while upper-case letters (``A``, ``B``, ...)
are constrained to bind to integer types; they are meant to represent
sizes and shapes. Moreover, |pycontracts| can do arithmetic and comparisons.

.. list-table::
   :widths: 50 50
   :header-rows: 1

   * - Contract expression
     - Meaning

   * - ``tuple(list[N], list[N])``
     - A tuple with two lists of the same length.

   * - ``tuple(list[N], list[M]), N<M``
     - A tuple with two lists, the first one being shorter.

   * - ``list[>0](type(x))``
     - A non-empty list containing elements of all the same type. 

   * - ``tuple(list(type(x)), list(type(x)))``
     - A tuple with two lists containing objects of the same type.


For the complete reference to the available contract expressions, see :ref:`reference`.

